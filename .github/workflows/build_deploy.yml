name: Build and Deploy MyCinema

on:
  workflow_dispatch:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  infrastructure:
    name: Set Up Infrastructure
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Delete CloudFormation Stack if in ROLLBACK_COMPLETE or ROLLBACK_FAILED
        run: |
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name mycinema-infrastructure --query "Stacks[0].StackStatus" --output text || true)
          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "ROLLBACK_FAILED" ]; then
            aws cloudformation delete-stack --stack-name mycinema-infrastructure
            echo "Stack in $STACK_STATUS state deleted. Waiting for deletion to complete..."
            aws cloudformation wait stack-delete-complete --stack-name mycinema-infrastructure
          fi

      - name: Set up AWS CloudFormation Stack
        run: |
          aws cloudformation deploy \
            --stack-name mycinema-infrastructure \
            --template-file infrastructure/cloudformation.yml \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              DBMasterUsername=${{ secrets.DB_USER }} \
              DBMasterUserPassword=${{ secrets.DB_PASSWORD }} \
              DBName=${{ secrets.DB_NAME }} \
              S3BucketName=${{ secrets.AWS_S3_BUCKET }}

      - name: Obtain DB Host
        id: get-db-host
        run: |
          DB_HOST=$(aws rds describe-db-instances --db-instance-identifier mycinema-db --query "DBInstances[0].Endpoint.Address" --output text --region ${{ secrets.AWS_REGION }})
          echo "DB_HOST=$DB_HOST" >> $GITHUB_ENV

      - name: Describe CloudFormation Stack Events (on failure)
        if: failure()
        run: |
          aws cloudformation describe-stack-events --stack-name mycinema-infrastructure

  backend:
    name: Build and Deploy Backend
    runs-on: ubuntu-latest
    needs: infrastructure

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          distribution: 'adopt'
          java-version: '21'

      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-maven-

      - name: Build with Maven
        run: mvn clean install --file backend/pom.xml -DskipTests

      - name: Create JWT private key file
        run: |
          mkdir -p backend/src/main/resources/META-INF/resources
          echo "${{ secrets.JWT_SIGN_KEY }}" > backend/src/main/resources/META-INF/resources/privateKey.pem

      - name: Build Docker image with Quarkus
        run: |
          IMAGE="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/mycinema-backend:latest"
          mvn package -Dquarkus.container-image.build=true \
            -Dquarkus.container-image.image=$IMAGE \
            -f backend/pom.xml \
            -DskipTests

      - name: List Docker images
        run: |
          docker images

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set aws_session_token ${{ secrets.AWS_SESSION_TOKEN }}
          aws configure set region ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      - name: Create ECR repository if not exists
        run: |
          aws ecr describe-repositories --repository-names mycinema-backend --region ${{ secrets.AWS_REGION }} || \
          aws ecr create-repository --repository-name mycinema-backend --region ${{ secrets.AWS_REGION }}

      - name: Push Docker image to ECR
        run: |
          IMAGE="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/mycinema-backend:latest"
          docker push $IMAGE

      # - name: Create ECS task definition based on template
      #   run: |
      #     export AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
      #     export AWS_REGION=${{ secrets.AWS_REGION }}
      #     export JWT_SIGN_KEY_LOCATION=${{ secrets.JWT_SIGN_KEY_LOCATION }}
      #     export ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
      #     export ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
      #     export DB_HOST=${{ env.DB_HOST }}
      #     export DB_PORT=${{ secrets.DB_PORT }}
      #     export DB_NAME=${{ secrets.DB_NAME }}
      #     export DB_USER=${{ secrets.DB_USER }}
      #     export DB_PASSWORD=${{ secrets.DB_PASSWORD }}
      #     export TMDB_API_KEY=${{ secrets.TMDB_API_KEY }}
      #     export OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
      #     cd infrastructure
      #     envsubst < ecs-task-definition-template.json > ecs-task-definition.json
      #     cat ecs-task-definition.json

      - name: Create ECS cluster if not exists
        run: |
          aws ecs describe-clusters --clusters mycinema-cluster --region ${{ secrets.AWS_REGION }} || \
          aws ecs create-cluster --cluster-name mycinema-cluster --region ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: infrastructure/ecs-task-definition.json
          service: mycinema-backend-service
          cluster: mycinema-cluster
          wait-for-service-stability: true
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          JWT_SIGN_KEY_LOCATION: ${{ secrets.JWT_SIGN_KEY_LOCATION }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          DB_HOST: ${{ env.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          TMDB_API_KEY: ${{ secrets.TMDB_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Get backend endpoint
        id: get-backend-endpoint
        run: |
          BACKEND_URL=$(aws ecs describe-services --cluster mycinema-cluster --services mycinema-backend-service --query "services[0].loadBalancers[0].dnsName" --output text --region ${{ secrets.AWS_REGION }})
          echo "BACKEND_API_URL=$BACKEND_URL" >> $GITHUB_ENV

  frontend:
    name: Build and Deploy Frontend
    runs-on: ubuntu-latest
    needs: backend

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '23.1.0'

      - name: Install dependencies
        run: |
          cd frontend
          npm install

      - name: Set API URL environment variable
        run: |
          echo "VUE_APP_API_URL=http://${{ env.BACKEND_API_URL }}" > frontend/.env

      - name: Run build
        run: |
          cd frontend
          npm run build

      - name: Deploy to S3
        uses: aws-actions/s3-sync-action@v3.1.0
        with:
          args: --delete
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          SOURCE_DIR: ./frontend/dist